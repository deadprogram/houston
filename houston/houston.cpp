//////////////////////////////////////////////////////////////////////////
// Auto-generated by RAD
//////////////////////////////////////////////////////////////////////////
#include <WProgram.h>

#include <SoftwareSerial.h>

//////////////////////////////////////////////////////////////////////////
// plugin directives
//////////////////////////////////////////////////////////////////////////
#undef int
#include <stdio.h>
char _str[32];
#define writeln(...) sprintf(_str, __VA_ARGS__); Serial.println(_str)
//////////////////////////////////////////////////////////////////////////
// method signatures
//////////////////////////////////////////////////////////////////////////
void loop();
void setup();
// sketch signatures
int main();
int joystick_y();
int joystick_x();
int joystick_throttle();
SoftwareSerial& my_lcd();
// plugin signatures
void print_sensor_position_plus(int reading);
void print_sensor_position(long pos);
void lcd_first_line();
void lcd_second_line();
void selectLineOne();
void set_backlight_level(int level);
void toggle_backlight();
void set_splash();
void backlightOff();
void ss_selectLineOne(SoftwareSerial& lcd);
void ss_set_backlight_level(SoftwareSerial& lcd, int level);
void ss_toggle_backlight(SoftwareSerial& lcd);
void ss_set_splash(SoftwareSerial& lcd);
void ss_backlightOff(SoftwareSerial& lcd);

//////////////////////////////////////////////////////////////////////////
// plugin structs
//////////////////////////////////////////////////////////////////////////
void loop();
void set_elevator();
void set_rudder();

//////////////////////////////////////////////////////////////////////////
// plugin external variables
//////////////////////////////////////////////////////////////////////////
char status_message[40] = "very cool";
char* msg[40];

//////////////////////////////////////////////////////////////////////////
// sketch external variables
//////////////////////////////////////////////////////////////////////////
long __rudder_deflection = 0;
long __throttle = 0;
byte __elevator_direction = 1;
long __y = 0;
long __elevator_deflection = 0;
long __x = 0;
byte __rudder_direction = 1;
long __deflection = 0;

// servo_settings array

// debounce array

// hysteresis array

// spectrasymbol soft pot array


//////////////////////////////////////////////////////////////////////////
// variable and accessors
//////////////////////////////////////////////////////////////////////////
int _joystick_y = 1;
int _joystick_x = 2;
int _joystick_throttle = 3;
SoftwareSerial _my_lcd = SoftwareSerial(6, 7);

int joystick_y() {
	return _joystick_y;
}
int joystick_x() {
	return _joystick_x;
}
int joystick_throttle() {
	return _joystick_throttle;
}
        SoftwareSerial& my_lcd() {
        return _my_lcd;
        }
        int read(SoftwareSerial& s) {
          return s.read();
        }
        void println( SoftwareSerial& s, char* str ) {
          return s.println( str );
        }
        void print( SoftwareSerial& s, char* str ) {
          return s.print( str );
        }
        void println( SoftwareSerial& s, int i ) {
          return s.println( i );
        }
        void print( SoftwareSerial& s, int i ) {
          return s.print( i );
        }


//////////////////////////////////////////////////////////////////////////
// assembler declarations
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// setup
//////////////////////////////////////////////////////////////////////////
void setup() {
	// pin modes
	pinMode(1, INPUT);
	pinMode(2, INPUT);
	pinMode(3, INPUT);
	pinMode(6, INPUT);
	pinMode(7, OUTPUT);
	digitalWrite( 1, HIGH ); // enable pull-up resistor for input
	digitalWrite( 2, HIGH ); // enable pull-up resistor for input
	digitalWrite( 3, HIGH ); // enable pull-up resistor for input
	// other setup
	_my_lcd.begin(9600);
Serial.begin(57600);
}

//////////////////////////////////////////////////////////////////////////
// helper methods
//////////////////////////////////////////////////////////////////////////

// RAD built-in helpers


//////////////////////////////////////////////////////////////////////////
// plugin methods
//////////////////////////////////////////////////////////////////////////
void print_sensor_position_plus(int reading){


/*  writeln("sensor: %d ", reading); */
  Serial.print("sensor: ");
  Serial.print(reading);

  
}

void print_sensor_position(long pos){
  Serial.print(pos);
}

void lcd_first_line(){  //puts the cursor at line 0 char 0.
   Serial.print(0xFE, BYTE);   //command flag
   Serial.print(128, BYTE);    //position
}

void lcd_second_line(){  //puts the cursor at line 0 char 0.
   Serial.print(0xFE, BYTE);   //command flag
   Serial.print(192, BYTE);    //position
}

void selectLineOne(){  //puts the cursor at line 0 char 0.
   Serial.print(0xFE, BYTE);   //command flag
   Serial.print(128, BYTE);    //position
}
void selectLineTwo(){  //puts the cursor at line 0 char 0.
   Serial.print(0xFE, BYTE);   //command flag
   Serial.print(192, BYTE);    //position
}
void clearLCD(){
   Serial.print(0xFE, BYTE);   //command flag
   Serial.print(0x01, BYTE);   //clear command.
}
void backlightOn(){  //turns on the backlight
    Serial.print(0x7C, BYTE);   //command flag for backlight stuff
    Serial.print(157, BYTE);    //light level.
}

void set_backlight_level(int level){  //turns on the backlight
  if (level > 29)
    level = 29;
    Serial.print(0x7C, BYTE);   //command flag for backlight stuff
    Serial.print(157 + level, BYTE);    //light level.
}

void toggle_backlight(){  //turns off the backlight
    Serial.print(0x7C, BYTE);   //command flag for backlight stuff
    Serial.print("|");     //light level for off.
    Serial.print(1);
}

void set_splash(){
  selectLineOne();
  Serial.print(" Ruby + Auduino");
  selectLineTwo();
  Serial.print(" RAD 0.2.4+     ");
  Serial.print(0x7C, BYTE);   // decimal 124, command flag for backlight stuff
  Serial.print(10, BYTE);
}

void backlightOff(){  //turns off the backlight
    Serial.print(0x7C, BYTE);   // decimal 124, command flag for backlight stuff
    Serial.print(128, BYTE);     //light level for off.
}
void serCommand(){   // decimal 254, a general function to call the command flag for issuing all other commands   
  Serial.print(0xFE, BYTE);
}

void softserial_sparkfun_lcd_init() {
}

void ss_selectLineOne(SoftwareSerial& lcd){  //puts the cursor at line 0 char 0.
   lcd.print(0xFE, BYTE);   //command flag
   lcd.print(128, BYTE);    //position
}
void ss_selectLineTwo(SoftwareSerial& lcd){  //puts the cursor at line 0 char 0.
   lcd.print(0xFE, BYTE);   //command flag
   lcd.print(192, BYTE);    //position
}
void ss_clearLCD(SoftwareSerial& lcd){
   lcd.print(0xFE, BYTE);   //command flag
   lcd.print(0x01, BYTE);   //clear command.
}
void ss_backlightOn(SoftwareSerial& lcd){  //turns on the backlight
    lcd.print(0x7C, BYTE);   //command flag for backlight stuff
    lcd.print(157, BYTE);    //light level.
}

void ss_set_backlight_level(SoftwareSerial& lcd, int level){  //turns on the backlight
  if (level > 29)
    level = 29;
    lcd.print(0x7C, BYTE);   //command flag for backlight stuff
    lcd.print(157 + level, BYTE);    //light level.
}

void ss_toggle_backlight(SoftwareSerial& lcd){  //turns off the backlight
    lcd.print(0x7C, BYTE);   //command flag for backlight stuff
    lcd.print("|");     //light level for off.
    lcd.print(1);
}

void ss_set_splash(SoftwareSerial& lcd){
  ss_selectLineOne(lcd);
  lcd.print(" Ruby + Auduino");
  ss_selectLineTwo(lcd);
  lcd.print(" RAD 0.2.4+     ");
  lcd.print(0x7C, BYTE);   // decimal 124, command flag for backlight stuff
  lcd.print(10, BYTE);
}

void ss_backlightOff(SoftwareSerial& lcd){  //turns off the backlight
    lcd.print(0x7C, BYTE);   // decimal 124, command flag for backlight stuff
    lcd.print(128, BYTE);     //light level for off.
}
void ss_serCommand(SoftwareSerial& lcd){   // decimal 254, a general function to call the command flag for issuing all other commands   
  lcd.print(0xFE, BYTE);
}


// serial helpers
int serial_available() {
          return (Serial.available() > 0);
        }
        
        char serial_read() {
          return (char) Serial.read();
        }
        
        void serial_flush() {
          return Serial.flush();
        }

        void serial_print( char str ) {
          return Serial.print( str );
        }

        void serial_print( char* str ) {
          return Serial.print( str );
        }

        void serial_print( int i ) {
          return Serial.print( i );
        }

        void serial_print( long i ) {
          return Serial.print( i );
        }

      	void serial_println( char* str ) {
          return Serial.println( str );
        }

        void serial_println( char str ) {
          return Serial.println( str );
        }

      	void serial_println( int i ) {
          return Serial.println( i );
        }

        void serial_println( long i ) {
          return Serial.println( i );
        }

        void serial_print( unsigned long i ) {
          return Serial.print( i );
        }


//////////////////////////////////////////////////////////////////////////
// main() function
//////////////////////////////////////////////////////////////////////////
int main() {
	init();
	setup();
	for( ;; ) { loop(); }
	return 0;
}

//////////////////////////////////////////////////////////////////////////
// loop!  Autogenerated by RubyToC, sorry it's ugly.
//////////////////////////////////////////////////////////////////////////
void
loop() {
softserial_sparkfun_lcd_init();
__x = analogRead(joystick_x());
__y = analogRead(joystick_y());
__throttle = analogRead(joystick_throttle());
set_elevator();
set_rudder();
ss_clearLCD(my_lcd());
ss_selectLineOne(my_lcd());
print(my_lcd(), "r: ");
if (__rudder_direction == 0) {
print(my_lcd(), "r ");
print(my_lcd(), __rudder_deflection);
};
if (__rudder_direction == 1) {
print(my_lcd(), "c ");
};
if (__rudder_direction == 2) {
print(my_lcd(), "l ");
print(my_lcd(), __rudder_deflection);
};
print(my_lcd(), "  e: ");
if (__elevator_direction == 0) {
print(my_lcd(), "u ");
print(my_lcd(), __elevator_deflection);
};
if (__elevator_direction == 1) {
print(my_lcd(), "c ");
};
if (__elevator_direction == 2) {
print(my_lcd(), "d ");
print(my_lcd(), __elevator_deflection);
};
ss_selectLineTwo(my_lcd());
print(my_lcd(), "throttle: ");
print(my_lcd(), __throttle);
delay(100);
}
void
set_elevator() {
if (__y < 517) {
__elevator_direction = 0;
__deflection = 547 - __y;
__elevator_deflection = __deflection * 90.0 / 373;
serial_print("e u ");
serial_println(__elevator_deflection);
};
if (__y > 577) {
__elevator_direction = 2;
__deflection = 920 - __y;
__elevator_deflection = __deflection * 90.0 / 373;
__elevator_deflection = 90 - __elevator_deflection;
serial_print("e d ");
serial_println(__elevator_deflection);
};
if (__y >= 517 && __y <= 577) {
__elevator_direction = 1;
serial_println("e c");
}
}
void
set_rudder() {
if (__x < 480) {
__rudder_direction = 0;
__deflection = 515 - __x;
__rudder_deflection = __deflection * 90.0 / 375;
serial_print("r r ");
serial_println(__rudder_deflection);
};
if (__x > 540) {
__rudder_direction = 2;
__deflection = 890 - __x;
__rudder_deflection = __deflection * 90.0 / 375;
__rudder_deflection = 90 - __rudder_deflection;
serial_print("r l ");
serial_println(__rudder_deflection);
};
if (__x >= 480 && __x <= 540) {
__rudder_direction = 1;
serial_println("r c");
}
}
